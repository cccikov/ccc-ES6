<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Proxy</title>
</head>

<body>
    <script type="text/javascript">
    function show(arr) {
        console.log("");
        arr.forEach(function(key, i) {
            console.log(i + "", key);
        });
        console.log("");
    }

    /**
     * Proxy
     *
     * Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程
     * Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。
     */
    {
        let obj = new Proxy({}, {
            get: function(target, key, receiver) {
                console.log(`getting ${key}!`);
                return Reflect.get(target, key, receiver);
            },
            set: function(target, key, value, receiver) {
                console.log(`setting ${key}!`);
                return Reflect.set(target, key, value, receiver);
            }
        });


        show([
            //  setting count!
            obj.count = 1, //1
            //  getting count!
            //  setting count!
            ++obj.count // 2
        ]);
    }

    {
        const target = {}; // 第一个参数是所要代理的目标对象
        const handler = {}; // 第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。

        /* ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。*/

        let proxy = new Proxy(target, handler);
        // Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。
    }

    {
        const person = {
            "name": "ccc",
            "age": 16,
            gender: "male"
        }

        const person_proxy = new Proxy(person, {
            get: function(target, property) {
                return 35;
            }
        });


        show([
            person.age, // 16
            person_proxy.age, // 35 要使得Proxy起作用，必须针对Proxy实例（person_proxy对象）进行操作，而不是针对目标对象（person对象）进行操作。
            person_proxy.job = "engineer", // engineer
            person_proxy.job, // 35
            person.job // engineer 如果handler没有设置拦截，那就等同于直接通向原对象。
            // 这里没有设置 set。所以给person_proxy设置就是直接给person设置。
        ]);

        /*Proxy 实例也可以作为其他对象的原型对象。*/
        let new_person = Object.create(person_proxy);
        console.log(new_person, new_person.age); // {} 35
    }

    /*
     *下面是 Proxy 支持的拦截操作一览。
     *对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。
     *
     *（1）get(target, propKey, receiver)
     *   拦截对象属性的读取，比如proxy.foo和proxy['foo']。
     *   最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。
     *
     *（2）set(target, propKey, value, receiver)
     *   拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
     *
     *（3）has(target, propKey)
     *   拦截propKey in proxy的操作，返回一个布尔值。
     *
     *（4）deleteProperty(target, propKey)
     *   拦截delete proxy[propKey]的操作，返回一个布尔值。
     *
     *（5）ownKeys(target)
     *   拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
     *
     *（6）getOwnPropertyDescriptor(target, propKey)
     *   拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
     *
     *（7）defineProperty(target, propKey, propDesc)
     *   拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
     *
     *（8）preventExtensions(target)
     *   拦截Object.preventExtensions(proxy)，返回一个布尔值。
     *
     *（9）getPrototypeOf(target)
     *   拦截Object.getPrototypeOf(proxy)，返回一个对象。
     *
     *（10）isExtensible(target)
     *   拦截Object.isExtensible(proxy)，返回一个布尔值。
     *
     *（11）setPrototypeOf(target, proto)
     *   拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。
     *   如果目标对象是函数，那么还有两种额外操作可以拦截。
     *
     *（12）apply(target, object, args)
     *   拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
     *
     *（13） construct(target, args)
     *   拦截 Proxy 实例作为构造函数调用的操作， 比如new proxy(...args)。
     */


    // get(target, propKey, receiver)
    {
        // get方法用于拦截某个属性的读取操作。

        let person = {
            name: "张三"
        };
        let proxy = new Proxy(person, {
            get: function(target, property) {
                console.log(target, property)
                if (property in target) {
                    return target[property];
                } else {
                    throw new ReferenceError("Property \"" + property + "\" does not exist.");
                }
            }
        });
        proxy.name // "张三"
            // proxy.age // 抛出一个错误
    }

    // set(target, propKey, value, receiver)
    {
        // set方法用来拦截某个属性的赋值操作。

        let validator = { // handler
            set: function(obj, prop, value) {
                if (prop === 'age') {
                    if (!Number.isInteger(value)) {
                        throw new TypeError('The age is not an integer');
                    }
                    if (value > 200 || value < 0) {
                        throw new RangeError('The age seems invalid');
                    }
                }
                // 对于age以外的属性，直接保存
                obj[prop] = value;
            }
        };

        let person = new Proxy({}, validator);
        // person.age = -1; // 报错 Uncaught RangeError: The age seems invalid


        {
            // 例子 有些私有属性
            var handler = {
                set(target, key, value) {
                    if (key[0] === '_') {
                        throw new Error(`Invalid attempt to set private "${key}" property`);
                    }
                    target[key] = value;
                    return true;
                }
            };

            var proxy = new Proxy({
                _name: "ccc",
            }, handler);

            show([
                proxy._name, // ccc
                // proxy._name = "tomato",  // Error: Invalid attempt to set private "_prop" property
                proxy.age = 12, // 12 非私有属性可以成功设置
                proxy, // {_name: "ccc", age: 12}
            ]);
        }
    }


    // apply(target, object, args)
    {
        var handler = {
            apply(target, ctx, args) {
                console.log(target, ctx, args)
                return Reflect.apply(...arguments);
            }
        };
        var target = function () { return 'I am the target'; };
        let proxy = new Proxy(target,handler);
        proxy();
    }
    </script>
</body>

</html>
