<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>函数的扩展---函数默认值</title>
</head>

<body>
    <script type="text/javascript">
    function show(arr) {
        console.log("");
        arr.forEach(function(key, i) {
            console.log(i + "", key);
        });
        console.log("");
    }



    /**
     * es5就是利用逻辑判断符这个特性来
     * || 只要第一个为true，就退出为true。 前者为true就返回前者 , 否则返回后者 ; 前者为true就不会执行后面的语句
     * && 只要第一个为false，就退出为false。 前者为false就返回前者 , 否则返回后者 ; 前者为false就不会执行后面的语句 cb && cb();
     */
    {
        // 对于复杂数据类型 , 比较简单 , 因为都为true ; 所以只要有传入参数就就为true , 没有就等于默认值
        show([!![], // true
            !!{} // true
        ]);

        function fn(obj, arr) {
            obj = obj || {
                name: "ccc"
            };
            return {
                obj,
                arr
            }
        }
        console.log(fn(null, [1]));
    }

    {
        // 对于5中基本数据类型来说就有些麻烦了 String Number Boolean undefined null
        // 其中 string 的空字符""是false的 ; number 的0是false的 ; boolean的false
        // undefined null 这两个数据类型就只有一种值 , 如果真的想要参数是这种类型的 , 直接设死就可以了

        // 如果默认值类型转换后为false还好办 , 可以用回以前的方法. 因为 string 和 number 数据类型中就只有一种情况为false
        function fn(str, num, bool, un, nu) {
            str = str || "";
            num = num || 0;
            bool = bool || false;
            un = undefined;
            nu = null;

            return {
                str,
                num,
                bool,
                un,
                nu
            }
        }
        console.log(fn("a", 1, true));

        // 对于布尔型 因为只有两种值 , 所以也无所谓 , 若要默认值为true
        function boolFn(bool) {
            let bool0 = bool !== undefined ? (bool == "false" ? false : bool) : true;
            let bool1 = typeof bool == "boolean" ? bool : true;
            let bool2 = bool == undefined ? true : bool;
            let bool3 = bool == undefined ? true : !!bool;
            let bool3_1 = bool == undefined ? true : Boolean(bool);
            let bool4 = bool === false ? false : true; // 这个是比较符合实际的 , 只有写上false才会是false
            let bool5 = (bool == false || bool === "false") ? false : true; // 这个是也比较符合实际的 只有写上false才会是false
            let bool6 = true && bool;
            let bool7 = bool && true;
            let bool8 = !!(true && bool);
            let bool9 = bool == undefined && (bool && true);

            return {
                bool,
                bool0,
                bool1,
                bool2,
                bool3,
                bool3_1,
                bool4,
                bool5,
                bool6,
                bool7,
                bool8
            }
        }
        show([
            boolFn(false),
            boolFn("false"),
            boolFn(),
            boolFn(null),
            boolFn(true),
            boolFn("true"),
            boolFn(0),
            boolFn(1),
            boolFn(""),
            boolFn("hello")
        ]);

        // 对于字符串 空字符""
        function strFn(str) {
            let str1 = str || "hello";
            let str2 = str !== undefined ? String(str) : "hello";

            return {
                str,
                str1,
                str2
            }
        }
        show([
            strFn(),
            strFn("你好"),
            strFn(""),
            strFn([1, 2, 3]),
            strFn({
                "name": "ccc"
            })
        ]);

        // 对于数字 数字0
        function numFn(num) {
            let num1 = num || 1;
            let num2 = num !== undefined ? Number(num) : 1;
            let num3 = num === 0 ? 0 : 1; //只有0和1

            return {
                num,
                num1,
                num2,
                num3
            }
        }
        show([
            numFn(),
            numFn(2),
            numFn(0),
            numFn(1),
            numFn([1, 2, 3]),
            numFn({"name": "ccc"}),
        ]);

        // 对于es5来说 , 一般都还是先判断一下参数是否有赋值
        // arg = arg !== undefined ? arg : default;
    }


    /**
     * es6 默认值
     * es6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
     */
    {
        function fn(x, y = 'World') {
            console.log(x, y);
        }
        fn('Hello'), // Hello World
        fn('Hello', 'China'), // Hello China
        fn('Hello', '') // Hello

        function Person(name = "ccc", age = 18) {
            this.name = name;
            this.age = age;
        }
        let person1 = new Person();
        console.log(person1); // {name: "ccc", age: 18}
    }


    /**
     * 与解构赋值默认值合用
     */
    {
        // 单用解构赋值默认值
        function foo({x, y = 5}){
            return [x,y];
        }
        show([
            foo({}), // [undefined, 5]
            foo({x:10}), // [10, 5]
            foo({x:10,y:20}), // [10, 20]
            // foo() // 报错 , 解构错误
        ]);

        function fn(url , {body = "", "method":method = "GET"}){
            return method;
        }
        show([
            fn("http://www.baidu.com",{}), // GET
            fn("http://www.baidu.com",{method:"POST"}), // POST
            // fn("http://www.baidu.com") //报错 , 解构错误
        ]);
    }

    {
        // 结合使用
        function fn(url, { method = 'GET' } = {}) {// 意思就是第二个参数默认是{}
            return method;
        }
        show([
            fn("http://www.baidu.com",{}), // GET
            fn("http://www.baidu.com",{method:"POST"}), // POST
            fn("http://www.baidu.com") // GET 相当于 fn("http://www.baidu.com",{}) 由于第二个参数默认值为{}
        ]);
    }

    {
        // 写法一 函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；
        function m1({x = 0, y = 0} = {}) { // 参数的默认值是{}
            return [x, y];
        }

        // 写法二 函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。
        function m2({x, y} = { x: 0, y: 0 }) {// 参数的默认值是{ x: 0, y: 0 }
            return [x, y];
        }

        // 写法三 函数参数的默认值是一个有具体属性的对象 ,
        function m3({x = "a", y = "b"} = { x: 0, y: 0 }) { // 参数的默认值是{ x: 0, y: 0 }
            return [x, y];
        }

        show([
            // 函数没有参数的情况
            m1(), // [0, 0] 相当于传入一个 {}
            m2(), // [0, 0] 相当于传入一个 { x: 0, y: 0 }
            m3(), // [0, 0] 相当于传入一个 { x: 0, y: 0 }

            // x和y都有值的情况
            m1({x: 3, y: 8}), // [3, 8]
            m2({x: 3, y: 8}), // [3, 8]
            m3({x: 3, y: 8}), // [3, 8]

            // x有值，y无值的情况
            m1({x: 3}), // [3, 0]
            m2({x: 3}), // [3, undefined]
            m3({x: 3}), // [3, "b"]

            // x和y都无值的情况
            m1({}), // [0, 0];
            m2({}), // [undefined, undefined]
            m3({}), // ["a", "b"]

            m1({z: 3}), // [0, 0]
            m2({z: 3}), // [undefined, undefined]
            m3({z: 3}) // ["a", "b"]
        ]);
    }

    /**
     * 参数默认值的位置
     */
    {
        // 一般来说有默认的参数都是尾参数(即都是放在最后的参数)
        function fn(x,y,z = 0){
            return [x,y,z];
        }
        show([
            fn(1,2), // [1, 2, 0]
            fn(1,2,3), // [1, 2, 3]
        ]);

        function foo(x = 0, y ,z){ // 如果不是最后 , 实际上这个参数是没法省略的
            return [x,y,z];
        }
        show([
            foo(undefined,2,3), // [0, 2, 3]
            foo(1,2,3), // [1, 2, 3]
            foo(null,2,3), // [null, 2, 3] 不同于es5的一般写法null是不触发默认值的(因为null == undef为true , 而es6的默认值都是采用 === 判断的) , 只有undefined
        ]);
    }

    /**
     * 函数的 length 属性
     *
     * length 是函数对象的一个属性值，指该函数有多少个必须要传入的参数
     */
    {
        show([
            (function (a) {}).length, // 1
            (function (a = 5) {}).length, // 0
            (function (a, b, c = 5) {}).length, // 2

            // 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
            (function (a = 0, b, c) {}).length, // 0
            (function (a, b = 1, c) {}).length, // 1
            // 所以再次说明设了默认值的参数放在最后是多么的重要
        ]);
    }
    </script>
</body>

</html>
