<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Generator --- 应用</title>
</head>

<body>
    <script type="text/javascript">
    function show(arr) {
        console.log("");
        arr.forEach(function(key, i) {
            console.log(i + "", key);
        });
        console.log("");
    }


    /////////
    // 状态机 //
    /////////
    {
        // es5
        {
            var ticking = true;
            var clock = function() {
                if (ticking)
                    console.log('Tick!');
                else
                    console.log('Tock!');
                ticking = !ticking;
            }
        }


        // es6
        {
            let clock = function*() {
                while (true) {
                    console.log('Tick!');
                    yield;
                    console.log('Tock!');
                    yield;
                }
            };
        }
    }



    ////////////////
    // 异步操作的同步化表达 //
    ////////////////
    {
        function makeAjaxCall(url, fn) { // 模拟ajax请求
            setTimeout(function() {
                fn && fn('{"value":"我是结果"}');
            }, 5000); // 如果这里不用定时器 , 就会报错 Generator is already running
            // 比如执行了一次next()，在方法里面判断这里处理同步的需求，在同步完成后又执行了一次next()，这一次对JS的单进程来说，就是上一次的next尚未结束，又开始了新的一次next，固然导致出现这个错误的警告。
        }

        function* main() {
            let result = yield request("http://some.url"); // 这里是异步操作

            let val = JSON.parse(result); // 以前这些步骤都要在makeAjaxCall的回调函数里面;有了Generator之后 , 可以写成同步那样
            console.log(val.value);
        }

        function request(url) {
            makeAjaxCall(url, function(response) {
                it.next(response);
            });
        }

        let it = main();
        it.next();
    }


    ///////////
    // 控制流管理 //
    ///////////
    {
        // 如果有一个多步操作非常耗时，采用回调函数

        {
            // es5
            function step1(val, fn) {
                setTimeout(function() {
                    console.log("去医院途中", `剩余电量${val}`);
                    var newValue = val - 14;
                    fn && fn(newValue);
                }, 500);
            }

            function step2(val, fn) {
                setTimeout(function() {
                    console.log("挂号并等待", `剩余电量${val}`);
                    var newValue = val - 45;
                    fn && fn(newValue);
                }, 500);
            }

            function step3(val, fn) {
                setTimeout(function() {
                    console.log("就医", `剩余电量${val}`);
                    var newValue = val - 2;
                    fn && fn(newValue);
                }, 500);
            }

            function step4(val, fn) {
                setTimeout(function() {
                    console.log("取药", `剩余电量${val}`);
                    var newValue = val - 15;
                    fn && fn(newValue);
                }, 500);
            }


            /*step1(98, function(value1) {

                step2(value1, function(value2) {

                    step3(value2, function(value3) {

                        step4(value3, function(value4) {

                            console.log("取完药立即走人", "最后剩余电量", value4);

                        });

                    });

                });

            });*/
        }

        {
            // es6 promise
            function promiseFn(fn, ...arg) {
                var pro = new Promise(function(resolve, reject) {
                    setTimeout(function() {
                        fn && fn(...arg);
                        resolve(arg[0]);
                    }, 500);
                })
                return pro;
            }

            function step1(val, fn) {
                var newValue = val - 14;
                return promiseFn(function(value, cb) {
                    console.log("去医院途中", `剩余电量${val}`);
                }, newValue);
            }

            function step2(val, fn) {
                var newValue = val - 45;
                return promiseFn(function(value, cb) {
                    console.log("挂号并等待", `剩余电量${val}`);
                }, newValue);
            }

            function step3(val, fn) {
                var newValue = val - 2;
                return promiseFn(function(value, cb) {
                    console.log("就医", `剩余电量${val}`);
                }, newValue);
            }

            function step4(val, fn) {
                var newValue = val - 15;
                return promiseFn(function(value, cb) {
                    console.log("取药", `剩余电量${val}`);
                }, newValue);
            }

            Promise.resolve(98)
                .then(function(result) {
                    return step1(result)
                })
                .then(step2)
                .then(step3)
                .then(step4);

        }






    }



    // end
    </script>
</body>

</html>
