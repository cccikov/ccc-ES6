<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Generator --- throw&return</title>
</head>

<body>
    <script type="text/javascript">
    function show(arr) {
        console.log("");
        arr.forEach(function(key, i) {
            console.log(i + "", key);
        });
        console.log("");
    }


    //////////////////////////////////
    // Generator.prototype.throw() //
    //////////////////////////////////

    /*Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。*/
    {
        let g = function*() {
            yield;
            try {
                yield;
            } catch (e) {
                console.log('内部捕获', e);
            }
        };

        let i = g();
        i.next();
        i.next();

        try {
            i.throw(new Error("错误A"));
            i.throw(new Error("错误B"));
        } catch (e) {
            console.log('外部捕获', e);
        }
        // 内部捕获 Error: 错误A
        // 外部捕获 Error: 错误B
        // i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。



        try {
            throw new Error('a');
            throw new Error('b');
        } catch (e) {
            console.log('外部捕获', e);
        }
        // 外部捕获 Error: a
        // 由于不是使用 Generator 实例的throw方法所以都是外部;第二次抛出错误由于catch语句已经执行了,所以不会再捕捉
    }


    /*Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。*/
    {
        function* foo() {
            var x = yield 3;
            var y = x.toUpperCase();
            yield y;
        }

        var it = foo();
        it.next(); // { value:3, done:false }

        try {
            it.next(42);
        } catch (err) {
            console.log(err);
        }
    }



    //////////////////////////////////
    // Generator.prototype.return() //
    //////////////////////////////////

    // end
    </script>
</body>

</html>
